//Leer un archivo y pasarlo a un buffer:
char* readFile(std::string path){
    std::ifstream ifs;
    int length;
    ifs.open(path);                     // Abrir el archivo
    ifs.seekg(0, std::ios::end);            // Mover hasta el final
    length = ifs.tellg();                   // Reportar la ubicaci√≥n (en este caso es el final del archivo)
    ifs.seekg(0, std::ios::beg);            // Volver al inicio del archivo
    char *buffer  = new char[length + 1];    // Asignar suficiente memoria para el buffer
    ifs.read(buffer, length);           // Leer el archivo y colocarlo completo en el buffer
    ifs.close();                            // Cerrar el manejador
    buffer[length] = '\0';                  // Colcocar el fin de cadena
    //std::cout<<buffer;

    return buffer;
}






TData ExprLiteral::solve(Environment* environment) {

    if (std::holds_alternative<int>(value) ) {
        int litVale = std::get<int>(value);
        return TData(litVale);
    }

    if (std::holds_alternative<double>(value) ) {
        double litVale = std::get<double>(value);
        return TData(litVale);
    }

    if (std::holds_alternative<bool>(value) ) {
        bool litVale = std::get<bool>(value);
        return TData(litVale);
    }

    if (std::holds_alternative<std::string>(value) ) {
        std::string litVale = std::get<std::string>(value);
        return TData(litVale);
    }

    return TData();
}


TData ExprGrouping::solve(Environment* environment) {
    return expression->solve(environment);
}


TData ExprArithmetic::solve(Environment* environment) {
    TData valueLeft = left->solve(environment);
    TData valueRight = right->solve(environment);

    if(oper->getName() == TokenName::PLUS){
        return valueLeft + valueRight;
    }
    if(oper->getName() == TokenName::MINUS){
        return valueLeft - valueRight;
    }
    if(oper->getName() == TokenName::STAR){
        return valueLeft * valueRight;
    }
    if(oper->getName() == TokenName::SLASH){
        return valueLeft / valueRight;
    }
}


TData ExprAssignment::solve(Environment* environment) {
    TData value = expression->solve(environment);
    environment->assign(name, value);
    return TData();
}



TData ExprCallFunction::solve(Environment* environment) {
    TData calleeResult = callee->solve(environment);

    std::vector<TData> args;
    for (Expression *argument: this->arguments) {
        TData result = argument->solve(environment);
        args.push_back(result);
    }

    // Check if it's callable
    if (!std::holds_alternative<KCallable*>(calleeResult.getValue()) ) {
        throw RuntimeException("La expresion no corresponde a una llamada valida.");
    }
    KCallable *function = std::get<KCallable*>(calleeResult.getValue());

    // check arity
    if (arguments.size() != function->arity()) {
        std::stringstream ss;
        ss << "Se esperaron " << function->arity() << "argumentos pero se recibierion " << arguments.size();
        throw RuntimeException(ss.str());
    }


    return function->call(environment, args);
}



TData ExprGet::solve(Environment* environment) {
    throw NotImplementedYetException("Not implemented yet");
}



TData ExprLogical::solve(Environment *environment) {
    TData valueLeft = left->solve(environment);
    TData valueRight = right->solve(environment);

    if(oper->getName() == TokenName::OR){
        return valueLeft || valueRight;
    }

    if(oper->getName() == TokenName::AND){
        return valueLeft && valueRight;
    }

    return TData();
}



TData ExprRelational::solve(Environment* environment) {
    TData valueLeft = left->solve(environment);
    TData valueRight = right->solve(environment);

    if(oper->getName() == TokenName::LESS){
        return valueLeft < valueRight;
    }
    if(oper->getName() == TokenName::LESS_EQUAL){
        return valueLeft <= valueRight;
    }
    if(oper->getName() == TokenName::GREATER){
        return valueLeft > valueRight;
    }
    if(oper->getName() == TokenName::GREATER_EQUAL){
        return valueLeft >= valueRight;
    }
    if(oper->getName() == TokenName::BANG_EQUAL){
        return valueLeft != valueRight;
    }
    if(oper->getName() == TokenName::EQUAL_EQUAL){
        return valueLeft == valueRight;
    }
}



TData ExprSet::solve(Environment* environment) {
    throw NotImplementedYetException("Not implemented yet");
}



TData ExprSuper::solve(Environment* environment) {
    throw NotImplementedYetException("Not implemented yet");
}



TData ExprThis::solve(Environment* environment) {
    throw NotImplementedYetException("Not implemented yet");
}




TData ExprUnary::solve(Environment* environment) {
    TData valueLeft = left->solve(environment);

    if(oper->getName() == TokenName::MINUS){
        return -valueLeft;
    }
    if(oper->getName() == TokenName::BANG){
        return !valueLeft;
    }
}



TData ExprVariable::solve(Environment* environment) {
    return environment->get(name);
}

